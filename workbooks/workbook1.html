<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Workbook 1</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.75.2"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><p class="docheader"><b>Java 1A Practical Class</b></p><div class="article" title="Workbook 1"><div class="titlepage"><div><div><h2 class="title"><a name="id2473774"></a>Workbook 1</h2></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="#sec:introduction">Introduction</a></span></dt><dt><span class="section"><a href="#sec:help">Getting help</a></span></dt><dt><span class="section"><a href="#sec:aims">Aim of this course</a></span></dt><dt><span class="section"><a href="#sec:bash">PWF Linux &amp; Bash</a></span></dt><dd><dl><dt><span class="section"><a href="#sec:bash-intro">Bash commands and programs</a></span></dt></dl></dd><dt><span class="section"><a href="#sec:java-tools">Java tools</a></span></dt><dd><dl><dt><span class="section"><a href="#sec:jar">Creating a jar file</a></span></dt></dl></dd><dt><span class="section"><a href="#sec:">Java Packages</a></span></dt><dt><span class="section"><a href="#sec:basic-types">Primitive types and operators</a></span></dt><dd><dl><dt><span class="section"><a href="#id2756362">Integral types</a></span></dt><dt><span class="section"><a href="#float-types">Floating-point types</a></span></dt><dt><span class="section"><a href="#boolean-type">The boolean type and operators</a></span></dt></dl></dd><dt><span class="section"><a href="#sec:comments">Comments</a></span></dt><dt><span class="section"><a href="#id2768231">Java Tick 1</a></span></dt></dl></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec:introduction"></a>Introduction</h2></div></div></div><p>In this course you will work through a series of practical exercises which will teach you the skills necessary to program in Java.  There are no lectures associated with this course, but there is a question based on the material in this course in the final exam. The material in this couse relies on the material taught concurrently in Object-Oriented Programming.</p><p>In contrast to the practical assessment associated with Foundations of Computer Science last term, this course requires you to attend a two hour practical lesson once a week for the eight weeks in Lent Term. During the practical lesson you will work through this workbook. You may take the workbook home at the end of the lesson to complete any unfinished sections. You will also need to complete the associated assessed exercise, or <em class="firstterm">tick</em>, described at the end of each workbook.</p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>An on-line version of this guide is available at:</p><p><a class="ulink" href="http://www.cl.cam.ac.uk/teaching/current/ProgJava" target="_top">http://www.cl.cam.ac.uk/teaching/current/ProgJava</a></p><p>You should check this page regularly for announcements and errata. You might find it useful to refer to the on-line version of this guide in order to follow any provided web links or to cut 'n' paste example code.</p></div></div><div class="section" title="Getting help"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec:help"></a>Getting help</h2></div></div></div><p>In each practical class you will find three course instructors who have the following duties:</p><div class="variablelist"><dl><dt><span class="term"><em class="firstterm">Lecturer</em></span></dt><dd><p>
The lecturer has written the material for this course and is able to offer advice on its content and correctness as well as more general help with programming.
</p></dd><dt><span class="term"><em class="firstterm">Assessor</em></span></dt><dd><p>
The assessor or <em class="firstterm">ticker</em> marks submitted
exercises and discusses them with students.
</p></dd><dt><span class="term"><em class="firstterm">Demonstrator</em></span></dt><dd><p>
The demonstrator is responsible for providing practical help on the content of the workbook and associated Java programming exercises.
</p></dd></dl></div></div><div class="section" title="Aim of this course"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec:aims"></a>Aim of this course</h2></div></div></div><p>The course is designed to accommodate students with diverse backgrounds in programming ability; consequently Java is taught from first principles in a practical class setting where you can work at your own pace. Students with prior experience at Java should complete this workbook as normal and then seek an extension exercise from the course lecturer.</p><p>Each practical class introduces a new programming topic and provides pointers to further background reading. Each exercise is designed to provide experience and insight into the practical effort
of designing, building and testing software. The work for each week is cumulative, building on work undertaken for previous weeks, so that by the end of the course you will have written a piece of software
capable of playing Conway's Game of Life.<sup>[<a name="id2722753" href="#ftn.id2722753" class="footnote">1</a>]</sup> By way of incentive, a screenshot of the graphical user interface of the final piece of software you will write is shown in <a class="xref" href="#fig:screenshot" title="Figure 1. Screenshot: Conway's Game of Life">Figure 1, “Screenshot: Conway's Game of Life”</a>.</p><div class="figure"><a name="fig:screenshot"></a><div class="figure-contents"><div class="mediaobject"><img src="figures/gameoflife.png" alt="Screenshot: Conway's Game of Life"></div></div><p class="title"><b>Figure 1. Screenshot: Conway's Game of Life</b></p></div><br class="figure-break"></div><div class="section" title="PWF Linux &amp; Bash"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec:bash"></a>PWF Linux &amp; Bash</h2></div></div></div><p>This course uses PWF Linux. If your PWF computer is currently running Windows, and you are unsure how to restart the machine in PWF Linux, please ask a demonstrator for the one page Starting PWF Linux guide and follow the instructions before continuing with this workbook.</p><p>Under Unix or Linux, a <em class="firstterm">shell</em> or <em class="firstterm">terminal</em> is often used to control the creation, execution and termination of applications. In this course we will be using a common shell, <em class="firstterm">Bash</em>, to control the Java tools. There are many other Integrated Development Environments (IDEs) available for Java, but we will avoid them in order to provide you with a sound understanding of the fundamentals. We recommend you use the Gnome Editor to write your Java applications—it's simple and has all the features you require—however if you are familiar with Linux or Unix you may use an alternative text editor of your choice.</p><p>Bash is a programming language in its own right. Unfortunately we won't have time to explore many of its features in this course, however improving your Bash skills in your own time will pay dividends in later years. If you are interested in finding out more you might like to take a look at the reference manual, but only if you have time.<sup>[<a name="id2723582" href="#ftn.id2723582" class="footnote">2</a>]</sup></p><div class="section" title="Bash commands and programs"><div class="titlepage"><div><div><h3 class="title"><a name="sec:bash-intro"></a>Bash commands and programs</h3></div></div></div><p>To start a Bash shell or terminal, right-click on the desktop and select <span class="guibutton">Open Terminal</span>. You should now see a new window with a white background. The text displayed in the Bash shell is sometimes called a <em class="firstterm">prompt</em> or <em class="firstterm">command line</em> and should look something like the following

</p><pre class="programlisting">crsid@machine:~&gt;
</pre><p>

where <code class="code">crsid</code> should be your own login name (e.g. <code class="code">arb33</code> or <code class="code">acr31</code>), <code class="code">machine</code> is the name of the computer you are using and the text between <code class="code">:</code> and <code class="code">&gt;</code> represents the <em class="firstterm">current working directory</em>, in this instance your home directory, which is represented by the special symbol <code class="code">~</code>.
</p><p>
You can execute Bash commands or start programs by typing the command or program name at the prompt. For example to print the current date and time you can use the Unix program <code class="code">date</code> :

</p><pre class="programlisting">crsid@machine:~&gt; date
Wed Oct 29 19:45:35 GMT 2008
crsid@machine:~&gt;
</pre><p>Try typing this command into your terminal now. Notice that the program <code class="code">date</code> prints out the current date and time to the shell. After the date and time has been printed by the program <code class="code">date</code>, the program terminates and the shell prompt is displayed again. We can pass arguments to the program which will modify its operation. Arguments are written on the same line as the program and are separated by whitespace. For example, we can modify the output of the <code class="code">date</code> program by specifying an alternative output format for the date and time:

</p><pre class="programlisting">crsid@machine:~&gt; date +"%Y-%m-%d %H:%M:%S"
2008-10-29 19:49:35
crsid@machine:~&gt;
</pre><p>In this case the additional argument after <code class="code">date</code> instructs the program to print the date and time formatted according to the ISO 8601 standard.<sup>[<a name="id2751667" href="#ftn.id2751667" class="footnote">3</a>]</sup> Many programs in Unix have an electronic manual associated with them which describe the additional arguments the program will accept. You can view the manual associated with a program by using the <code class="code">man</code> program. The <code class="code">man</code> program accepts the name of a program and displays the relevant manual (if any). To list the options associated with the <code class="code">date</code> program, type the following at your prompt now:

</p><pre class="programlisting">crsid@machine:~&gt; man date
</pre><p>



Your shell should now display the manual page for <code class="code">date</code>. You can scroll through the options for date by using the up arrow (<span class="symbol">↑</span>) and down arrow (<span class="symbol">↓</span>) keys on your keyboard. You can quit the <code class="code">man</code> program by typing <span class="keycap"><strong>q</strong></span>.  
</p><p>Other Bash programs you might find useful include: <code class="code">ls</code> to list the files inside a directory, <code class="code">rm</code> to remove a file or directory, <code class="code">mkdir</code> to create a new directory, and <code class="code">cd</code> to change the current working directory. You can use the <code class="code">man</code> program to determine how to use these programs just as you did for <code class="code">date</code> above.</p></div></div><div class="section" title="Java tools"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec:java-tools"></a>Java tools</h2></div></div></div><p>In this section you will write a simple Java program and use the java tools to compile and execute it.</p><p>Java is a <em class="firstterm">compiled</em> language, which means that the Java programs you write must be transformed into another format before execution. To peform this transformation you need a <em class="firstterm">compiler</em> and in this course we will use the java compiler called <code class="code">javac</code> to convert Java <em class="firstterm">source code</em> into Java <em class="firstterm">bytecode</em>. Java bytecode can then be run using the Java runtime program <code class="code">java</code>. Compilers for some languages, such as C, produce <em class="firstterm">machine code</em> as output which can then be run directly on the CPU. The Java designers chose to use the bytecode format because it is portable and can be moved between computers and operating systems without the need for recompilation; the price paid for this portability is the need for a runtime program to assist the computer in the execution of the bytecode.  Running the java program launches a <em class="firstterm">Java Virtual Machine</em> which in turn can execute Java bytecode.
</p><p>Open a copy of Gnome Editor (or your favourite Linux text editor if you have one) and create a new file by selecting the <span class="guibutton">New</span> button on the graphical interface or typing <span class="keycap"><strong>Ctrl+n</strong></span>. In this new file, type in the following Java source code:  

</p><pre class="programlisting">class Example {
 public static String message = "Hello, world";
 public static void main(String[] args) {
  System.out.println(message);
 }
}
</pre><p>
</p><p>Save this Java source code to disk using the filename <code class="code">Example.java</code>. (In Java the filename must be the same as the name following the keyword <code class="code">class</code> with the extension '<code class="code">.java</code>' appended to it.)</p><p>This example contains a lot of syntax and keywords. Java has quite a lot essential syntax, even for the most basic program, which you do not need to fully understand this week. You will hear more about it in the Object-Oriented Programming course, and you will gain a thorough understanding of it in future practical classes. Even if it looks complex now, it won't do by the end of the term, and the main message at the moment is <span class="emphasis"><em>don't panic</em></span>, you're not supposed to understand it!</p><p>Having said all this, you might find an overview of the example helpful, so here it is. The phrase <code class="code">class Example { ... }</code> provides a definition of a new data structure, in this case called <code class="code">Example</code>. This data structure, or <em class="firstterm">class</em>, can store values (such as integers, strings, and so on) which in object-oriented programming parlance are called <em class="firstterm">fields</em>; the example class above has a single field called <code class="code">message</code>, which stores an item of type <code class="code">String</code>. A class can also contain program code written as one or more <em class="firstterm">methods</em>; the example above has a single method called <code class="code">main</code> which takes an array of strings (<code class="code">String[] args</code>) and returns nothing (<code class="code">void</code>). This is conceptually similar to an ML function which takes a <code class="code">string list</code> and returns <code class="code">unit</code>. A method which is of the form <code class="code">public static void main(String[] args)</code> is special in Java and indicates the point at which program execution begins.</p><p>To compile the source code to bytecode make sure that your current working directory for your Bash shell is the same as the directory containing your source code. For example, if you saved <code class="code">Example.java</code> into the directory called <code class="code">java</code> inside your home directory then you will need to change into that directory before trying to compile the code: 

</p><pre class="programlisting">crsid@machine:~&gt; cd java
crsid@machine:java&gt;
</pre><p>
</p><p>In the rest of this workbook we assume your current working directory is your home directory. To compile your Java source code you should type in the following:

</p><pre class="programlisting">crsid@machine:~&gt; javac Example.java
</pre><p>

The prompt should return without any textual output. If the compiler does print some output it will describe one or more warnings or errors in the program because you have not typed in the source code correctly. In this case take another look at your file and correct any mistakes you find; the output from the compiler may help you to identify where these are.
</p><p>If your program has compiled correctly, the compiler will have generated a file called <code class="code">Example.class</code>. You can check this exists by using the program <code class="code">ls</code>. The file <code class="code">Example.class</code> is the bytecode version of your Java source code which you can execute with the <code class="code">java</code> program. Run your Java bytecode now as follows:

</p><pre class="programlisting">crsid@machine:~&gt; java Example
Hello, world
crsid@machine:~&gt;
</pre><p>

Notice that we do not include the '<code class="code">.class</code>' file extension when calling the <code class="code">java</code> program.  What has happened here is that the program code we wrote describes a class called <code class="code">Example</code>.  The compiler has turned this into bytecode and stored it in a file called <code class="code">Example.class</code>.  Next we launched java and told it which class to use (not which file).  However, in order to use the class the Java Virtual Machine must first load the class' bytecode.  One of the means for doing this is to look for a file on disk with the same name and a <code class="code">.class</code> extension and so everything works.</p><div class="section" title="Creating a jar file"><div class="titlepage"><div><div><h3 class="title"><a name="sec:jar"></a>Creating a jar file</h3></div></div></div><p>In all but the most trivial of Java projects you will produce multiple classes, and because the Java compiler produces one bytecode file for each class, Java provides a convenient mechanism for encapsulating multiple bytecode files into a single file on disk. The encapsulating file is called a <em class="firstterm">jar</em> file and is similar in concept to zip files (Windows), DMG files (MacOS X) or tar files (Unix systems).  Your task in this section is to package up your example program and check that you can execute it.
</p><p>To create a jar file we will use the command line tool called <code class="code">jar</code>. The <code class="code">jar</code> program accepts a variety of options on the command line which you can read about by typing <code class="code">man jar</code>. To create a suitable jar file for the example above you should type the following, making sure that your current directory includes the <code class="code">Example.java</code> and <code class="code">Example.class</code> files before doing so:

</p><pre class="programlisting">crsid@machine:~&gt; jar cfe Example.jar Example Example.*
</pre><p>
</p><p>The command line arguments to the execution of program <code class="code">jar</code> above do the following things:

</p><div class="variablelist"><dl><dt><span class="term"><code class="code">cfe</code></span></dt><dd><p>
Instructs the <code class="code">jar</code> program to <code class="code">c</code>reate a <code class="code">f</code>ile with the specified <code class="code">e</code>ntry point (see below).
</p></dd><dt><span class="term"><code class="code">Example.jar</code></span></dt><dd><p>
The name of the jar file to be created.
</p></dd><dt><span class="term"><code class="code">Example</code></span></dt><dd><p>
The <em class="firstterm">entry point</em>, specified as the name of the class which contains the special main function, where program execution should begin.
</p></dd><dt><span class="term"><code class="code">Example.*</code></span></dt><dd><p>
The list of additional files to include in the jar file. In this case the <code class="code">*</code> wildcard has been used and is expanded by Bash into all files in the current directory which match the pattern <code class="code">Example.*</code>. This will include both <code class="filename">Example.class</code> and <code class="filename">Example.java</code>; these two file names will then be passed separately to the <code class="code">jar</code> program. It is equivalent to writing: <code class="code">jar cfe Example.jar Example Example.class Example.java</code>.
</p></dd></dl></div><p>
</p><p>
After executing the above commands in your shell you should find a jar file called <code class="filename">Example.jar</code> in your current directory which contains both <code class="filename">Example.java</code> and <code class="filename">Example.class</code> and creates an internal <em class="firstterm">manifest</em> file which states that the <code class="code">Example</code> class contains the special 'main' function where execution begins. You can check the contents of the jar file by using the <code class="code">t</code>est feature of the jar tool:

</p><pre class="programlisting">crsid@machine:~&gt; jar tf Example.jar
META-INF/
META-INF/MANIFEST.MF
Example.class
Example.java
crsid@machine:~&gt; 
</pre><p>
You can see that the jar tool has created an additional directory containing a file called <code class="filename">MANIFEST.MF</code> as well as including both <code class="filename">Example.java</code> and <code class="filename">Example.class</code>. In general, the manifest file can contain a multitude of configuration parameters and options to control the execution of the Java application. You can write a manifest file by hand to specify such options, however this will not be necessary in this course.</p><p>Once you have built a jar file, you can load the classes contained within it and execute the class specified by the entry point using the <code class="code">java</code> program with the <code class="code">-jar</code> option:
</p><pre class="programlisting">crsid@machine:~&gt; java -jar Example.jar
Hello, world
crsid@machine:~&gt; 
</pre><p>

If you do not see the output '<code class="code">Hello, world</code>', then you have not packaged your jar file correctly; in this case you will need to review the steps covered in this section and if you're still stuck seek help from the demonstrator or lecturer.
</p></div></div><div class="section" title="Java Packages"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec:"></a>Java Packages</h2></div></div></div><p>In order to manage large projects and prevent different programmers from accidentally giving the same name to two different implementations of a class, Java classes can be placed in a <em class="firstterm">package</em>. By convention, Java package names use an Internet Domain Name Service (DNS) name as a prefix for a package name. Consequently in this course you should package all of your code inside <code class="code">uk.ac.cam.your-crsid</code> where <code class="code">your-crsid</code> should be replaced by your own PWF username. In other words, if you log in to PWF machines with the username <code class="code">arb33</code> all your java code should have the package prefix <code class="code">uk.ac.cam.arb33</code>.</p><p>You must declare which package a class is associated with at the very top of the source file. For example, to place the 'hello world' example above into the package <code class="code">uk.ac.cam.arb33.examples</code> you write the following:

</p><pre class="programlisting">package uk.ac.cam.arb33.examples;

class Example {
 public static String message = "Hello, world";
 public static void main(String[] args) {
  System.out.println(message);
 }
}
</pre><p>
</p><p>The source file should still be saved into a file called <code class="filename">Example.java</code> but should be placed inside the directory hierarchy which mirrors the package name. Therefore in the above example, <code class="filename">Example.java</code> should be saved inside a directory heirarchy of <code class="code">uk/ac/cam/arb33/examples</code>. Such a directory path can be created with the following Bash commands:

</p><pre class="programlisting">crsid@machine:~&gt; mkdir uk
crsid@machine:~&gt; mkdir uk/ac
crsid@machine:~&gt; mkdir uk/ac/cam
crsid@machine:~&gt; mkdir uk/ac/cam/arb33/
crsid@machine:~&gt; mkdir uk/ac/cam/arb33/examples
</pre><p>

The electronic manual for <code class="code">mkdir</code> explains how to do this in one step:

</p><pre class="programlisting">crsid@machine:~&gt; mkdir -p uk/ac/cam/arb33/examples
</pre><p>

You should then move <code class="filename">Example.java</code> into this location using the <code class="code">mv</code> command:

</p><pre class="programlisting">crsid@machine:~&gt; mv Example.java uk/ac/cam/arb33/examples
</pre><p>
</p><p>Bash provides <em class="firstterm">command completion</em> to reduce the amount of typing required for commands like these.  Simply type the first part of the command or the directory path before pressing the <code class="code">[tab]</code> key on your keyboard.  If there is a unique completion then Bash will fill it in for you.  If there are multiple completions then simply press tab again to see them or continue typing to disambiguate the options.</p><p>To compile a program which is inside a package, the current working directory of the shell must contain the outermost directory of the package (in other words, in the case above, the directory <code class="filename">uk</code> should be directly inside the current working directory). The example can then be compiled as follows:

</p><pre class="programlisting">crsid@machine:~&gt; javac uk/ac/cam/arb33/examples/Example.java
</pre><p>

the compiler will put the <code class="filename">Example.class</code> file in the same directory as <code class="filename">Example.java</code>. 
</p><p>The associated jar file can be built in a similar fashion, except that the name of the class must now include the name of the package it is within:

</p><pre class="programlisting">crsid@machine:~&gt; jar cfe Example.jar \ 
uk.ac.cam.arb33.examples.Example \  
uk/ac/cam/arb33/examples/Example.*
crsid@machine:~&gt; 
</pre><p>


(Note: the backslash character (<code class="code">\</code>) is used to continue a single command onto an extra line; you do not have to type this character in if you write all the text on a single line.)</p><p>The jar file can then be executed using the <code class="code">java</code> program as before:

</p><pre class="programlisting">crsid@machine:~&gt; java -jar Example.jar
Hello, world
crsid@machine:~&gt; 
</pre><p>
</p><p>When you become a more proficient Java programmer, you may wish to keep your source files in a separate location from your bytecode files. This is possible, but for now we will forego this complexity and keep all the files in one directory hierarchy.</p></div><div class="section" title="Primitive types and operators"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec:basic-types"></a>Primitive types and operators</h2></div></div></div><p>You have now successfully compiled, packaged and executed a simple Java program.  We will now introduce the basic data-types provided in Java and the operators you can use to manipulate them.  You will use this knowledge at the end of the practical to complete the assessed exercise.</p><p>In Java we use <em class="firstterm">variables</em> to allocate computer memory to store either: (i) a value of a basic, or <em class="firstterm">primitive</em>, type or (ii) a reference to an Object. This workbook focuses on how to create and manipulate variables of a primitive type; you will investigate Objects and references to Objects in future weeks. By the end of this term, you should be able to list and use all the primitive types and explain the behaviour of the operators which act upon them.</p><p>Variables in Java are different to values in ML.  Values in ML are normally immutable, in other words, once you create them you cannot modify them. In Java it is much more common to program with mutable "values" than immutable ones. A mutable "value" in Java can be modified, possibly many times, after it has been created. Consequently such mutable "values" in Java are called <em class="firstterm">variables</em> in deference to the fact that Java programs commonly modify the contents of a variable during execution.</p><p>There are eight primitive storage types in Java which can be used to store values representing truth or falsity, integers of varying size, or floating point numbers. <a class="xref" href="#tab:basic-types" title="Table 1. The primitive types">Table 1, “The primitive types”</a> shows the names, sizes and storage capacity of these types. At this stage you should use this table to get an idea of what's there and refer back to it as you need to.  By the end of the course we expect you to be able to remember the contents.  The meaning of each of the columns in the table is as follows: 

</p><div class="variablelist"><dl><dt><span class="term">Name</span></dt><dd><p>The sequence of characters in a Java source file used to refer to the type.</p></dd><dt><span class="term">Size (bits)</span></dt><dd><p>The amount of computer memory allocated to store the data in a variable.</p></dd><dt><span class="term">Minimum and maximum</span></dt><dd><p>The larger the size (bits) of the type, the greater the number of unique values it can store. The Floating-Point Computation course will give you more details about <code class="code">float</code> and <code class="code">double</code> types. These are defined by the international standard IEEE 754.</p></dd><dt><span class="term">Example literals</span></dt><dd><p>A literal expresses a value which may be stored in a variable. Some examples are given in the table and we'll go into more detail over the next few pages.</p></dd></dl></div><p>	
</p><div class="table"><a name="tab:basic-types"></a><div class="table-contents"><table summary="The primitive types" border="1"><colgroup><col align="left"><col align="left"><col align="left"><col align="left"><col align="left"></colgroup><thead><tr><th align="left">name</th><th align="left">size (bits)</th><th align="left">minimum</th><th align="left">maximum</th><th align="left">example literals</th></tr></thead><tbody><tr><td align="left"><code class="code">byte</code></td><td align="left">8</td><td align="left">-128</td><td align="left">127</td><td align="left"> </td></tr><tr><td align="left"><code class="code">char</code></td><td align="left">16</td><td align="left">0</td><td align="left">2<sup>16</sup>-1</td><td align="left"><code class="code">'A'</code></td></tr><tr><td align="left"><code class="code">short</code></td><td align="left">16</td><td align="left">-2<sup>15</sup></td><td align="left">2<sup>15</sup>-1</td><td align="left"> </td></tr><tr><td align="left"><code class="code">int</code></td><td align="left">32</td><td align="left">-2<sup>31</sup></td><td align="left">2<sup>31</sup>-1</td><td align="left"><code class="code">52</code>, <code class="code">0x34</code>, or <code class="code">064</code></td></tr><tr><td align="left"><code class="code">float</code></td><td align="left">32</td><td align="left">IEEE 754</td><td align="left">IEEE 754</td><td align="left"><code class="code">0.0F</code>, <code class="code">-1e4F</code></td></tr><tr><td align="left"><code class="code">long</code></td><td align="left">64</td><td align="left">-2<sup>63</sup></td><td align="left">2<sup>63</sup>-1</td><td align="left"><code class="code">4294967296L</code></td></tr><tr><td align="left"><code class="code">double</code></td><td align="left">64</td><td align="left">IEEE 754</td><td align="left">IEEE 754</td><td align="left"><code class="code">3.14e-1D</code>, <code class="code">2.7</code>, or <code class="code">1e4</code></td></tr><tr><td align="left"><code class="code">boolean</code></td><td align="left">N/A</td><td align="left">N/A</td><td align="left">N/A</td><td align="left"><code class="code">false</code> or <code class="code">true</code></td></tr></tbody></table></div><p class="title"><b>Table 1. The primitive types</b></p></div><br class="table-break"><p>We can create a variable of a particular primitive type by writing the name of the type followed by a memorable name. This can be done either within a class definition (in which case it is also called a <em class="firstterm">field</em>) or within a method such as the main method we saw earlier. Below is a simple example which declares two variables, both of type <code class="code">int</code>:

</p><pre class="programlisting">class VariableExample {
 public static int fieldVar;
 public static void main(String[] args) {
  int methodVar;
 }
}
</pre><p>
</p><p>You should choose the names of variables carefully, partly because a good name will improve readability (and therefore is strongly encouraged from a software engineering perspective), but also because some names cannot be used to name variables in Java. The following names are <span class="emphasis"><em>reserved</em></span> words in Java:

</p><pre class="programlisting">abstract   assert       boolean    break    byte      case      
catch      char         class      const    continue  default    
do         double       else       enum     extends   false     
final      finally      float      for      goto      if           
implements import       instanceof int      interface long
native     new          null       package  private   protected 
public     return       short      static   strictfp  super      
switch     synchronized this       throw    throws    transient  
true       try          void       volatile while
</pre><p>

using any of these words as a name for a variable will result in a compile error. If you encounter this problem, the solution is to change the name of the variable. You will learn what many of these reserved words do in this course, but not all. Some of the advanced features of Java will not be taught until the second year.
</p><div class="section" title="Integral types"><div class="titlepage"><div><div><h3 class="title"><a name="id2756362"></a>Integral types</h3></div></div></div><p>Java has five primitive types which support storage of a range of integral values: <code class="code">byte</code>, <code class="code">char</code>, <code class="code">short</code>, <code class="code">int</code> and <code class="code">long</code>. To explore the primitive integral types you will need to write simple Java programs. To get you started, follow the instructions below, making sure you replace <code class="code">your-crsid</code> with your username. For example, if your username is <code class="code">arb33</code> you should use <code class="code">arb33</code> in place of <code class="code">your-crsid</code>.</p><div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem"><p>
 	Create a new Java source file called <code class="filename">PrimitiveInt.java</code> inside the directory <code class="code">uk/ac/cam/your-crsid/examples</code> you created in the last section.
 </p></li><li class="listitem"><p>
Enter the following Java program into the file called <code class="filename">PrimitiveInt.java</code>:
</p><pre class="programlisting">package uk.ac.cam.your-crsid.examples;

class PrimitiveInt {
 public static void main(String[] args) {
  int i;                 //create a variable called i
  i = 1;                 //update i with the value 1
  i = i + 1;             //update i with the value of "i+1" 
  System.out.println(i); //print out the current value of i
 }
}
</pre><p>
 </p></li><li class="listitem"><p>
 	Compile your program using the <code class="code">javac</code> program.
 </p></li><li class="listitem"><p>
 	Run your program using the <code class="code">java</code> program.
 </p></li></ul></div><p>If you have followed the steps correctly, your program should print out the number 2. Make sure you work through the above even if it seems obvious! You will need to modify this program later.
	</p><div class="section" title="Numeric operators"><div class="titlepage"><div><div><h4 class="title"><a name="id2764132"></a>Numeric operators</h4></div></div></div><p>The first set of operators on primitive types we will consider are the numeric operators. These perform numeric or mathematical operations with values of a primitive type and are written as follows: <code class="code">+</code> (addition), <code class="code">-</code> (subtraction), <code class="code">*</code> (multiplication), <code class="code">/</code> (division), <code class="code">%</code> (modulus or remainder). 
These are <em class="firstterm">infix</em> <em class="firstterm">binary</em> operators. In this context, the word binary means that the operator takes two <em class="firstterm">operands</em> and infix means that the operator is written between the arguments. For example, <code class="code">a + b</code> uses the infix binary operator <code class="code">+</code> to add the values stored in the variables <code class="code">a</code> and <code class="code">b</code> together; <code class="code">a</code> and <code class="code">b</code> are the left-hand and right-hand operands to the operator <code class="code">+</code>.</p><p>The modulus operator (<code class="code">%</code>) might be unfamiliar to you. The operation <code class="code">a % b</code> calculates the remainder after <code class="code">a</code> has been divided by <code class="code">b</code>. 
This can be restated as follows: <code class="code">a % b</code> finds a number x such that <code class="code">a</code> - x is exactly divisible by <code class="code">b</code>.  An alternative way of thinking about the modulus operation uses clock arithmetic: the position of the hour hand twenty-six hours after midnight can be calcuated as <code class="code">26 % 12</code>, which of course yields the answer two because twenty-six hours after midnight, the hour hand will be be located at position two on the clock face.
The answer to <code class="code">26 % 5</code> can be found by considering a clock which completes a full revolution every 5 hours (rather than the usual 12) and consequently has only five hours marked on the face. <a class="xref" href="#fig:clock-arithmetic" title="Figure 2. Clock arithmetic">Figure 2, “Clock arithmetic”</a> contains a graphical illustration of <code class="code">26 % 12</code> and <code class="code">26 % 5</code>.
</p><div class="figure"><a name="fig:clock-arithmetic"></a><div class="figure-contents"><div class="mediaobject"><img src="figures/clock-arithmetic.png" alt="Clock arithmetic"></div></div><p class="title"><b>Figure 2. Clock arithmetic</b></p></div><br class="figure-break"><p>A unary operator is an operator which takes a single argument. The unary operator <code class="code">-</code> (minus) is used to negate a literal or the value stored in a variable. For example, <code class="code">-a</code> changes the sign of the value stored in the variable <code class="code">a</code>.</p><p>Every operator in Java produces a result which can then be used as a left-hand or right-hand operand with another operator. The term <span class="emphasis"><em>expression</em></span> is used to describe a valid construct made up of operators, variables, literal values and methods invocations (which will be explained later in the course); an expression is turned into a <span class="emphasis"><em>statement</em></span>, or unit of execution, by appending it with a semi-colon (<code class="code">;</code>). The order in which operands are executed in a statement depends on operator precedence, which is reasonably intuitive, but does have the potential to catch you out occasionally. You can override the default operator precendence by using round brackets. For example, the expression <code class="code">1 + 2 * 3</code> produces the result <code class="code">7</code>. If you want the addition to take place before the multiplication you can write <code class="code">(1 + 2) * 3</code>, giving the result <code class="code">9</code>.</p><div class="section" title="Numeric operators with assignment"><div class="titlepage"><div><div><h5 class="title"><a name="id2762156"></a>Numeric operators with assignment</h5></div></div></div><p>In the <code class="code">PrimitiveInt</code> program, the assignment operator (<code class="code">=</code>) is used to assign a new value to the variable <code class="code">i</code>. The assignment operator is another example of a binary infix operator in which the left-hand operand is the name of a variable, and the right-hand operand is a value which the variable is updated to store. As mentioned before, every operator in Java produces a result, and the result of evaluating the assignment operator is the value of the right-hand operand. For example, the expression "<code class="code">i = 1</code>" has the value <code class="code">1</code> as its result.</p><div class="sidebar" title="Assignment operator"><p class="title"><b>Assignment operator</b></p><p>Write answers to all of the questions found in questions boxes such as this one into a plain text file called <code class="filename">answers.txt</code>. You will need to include your <code class="filename">answers.txt</code> file in your submission for your first Java Tick. Further information about the submission of the tick can be found at the end of this workbook.</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
	Modify <code class="code">PrimitiveInt</code> to demonstrate that the expression <code class="code">a = b</code> returns <code class="code">b</code> as its result. Include your modified or additional line(s) in <code class="filename">answers.txt</code>.
 </p></li></ol></div></div><p>The next operators to consider are the unary increment and decrement operators written as <code class="code">++</code> and <code class="code">--</code> respectively. They combine together both an assignment and an addition operation, and the position of the increment and decrement operators with respect to the variable name determines the value returned as a result.</p><p>If the increment operator is written before the name of the variable, then it is more accurately called the <em class="firstterm">pre-increment</em> operator. For example, given a variable <code class="code">i</code>, the pre-increment operator is written <code class="code">++i</code>. The pre-increment operator is equivalent to writing the expression <code class="code">i = i + 1</code>, and therefore <code class="code">++i</code> increases the value stored in <code class="code">i</code> by one and also returns the increased valued as its result.</p><p>In contrast, if the increment operator is written after the name of the variable, then this operator is more accurately called the <em class="firstterm">post-increment</em> operator. For example, for the variable <code class="code">i</code>, the post-increment operator is written <code class="code">i++</code>. The post-increment operator increments the value stored in <code class="code">i</code> by one, but the result returned by the operator is the value stored in <code class="code">i</code> <span class="emphasis"><em>before</em></span> it was incremented.</p><p>The pre-decrement and post-decrement operators behave similarly to the pre- and post-increment operators except that the value stored in the variable is reduced by one rather than increased by one.</p><div class="sidebar" title="Pre- and post-decrement"><p class="title"><b>Pre- and post-decrement</b></p><p>
	Add the following code to the <code class="code">main</code> function in your copy of <code class="code">PrimitiveInt</code>
	</p><pre class="programlisting">		int j = 10;
		System.out.println(j--);
		System.out.println(j);
	</pre><p>
	</p><div class="orderedlist"><ol class="orderedlist" start="2" type="1"><li class="listitem"><p>
	What does the code snippet above print out? Why?
</p></li><li class="listitem"><p>
	If you replace <code class="code">j--</code> with <code class="code">--j</code> in the above code snippet, what does the program print out?
</p></li></ol></div></div><p>Java also provides shorthand forms for all numeric operators when combined with  assignment. For example, <code class="code">i = i + 10</code> can be shortened to <code class="code">i += 10</code> and <code class="code">j = j * k</code> can be shortened to <code class="code"> j *= k</code>. A summary of the numeric and assignment operators is shown in <a class="xref" href="#tab:numeric-assign" title="Table 2. Numeric operators and assignment">Table 2, “Numeric operators and assignment”</a>.</p><div class="table"><a name="tab:numeric-assign"></a><div class="table-contents"><table summary="Numeric operators and assignment" border="1"><colgroup><col align="left"><col align="left"></colgroup><tbody><tr><td align="left"><code class="code">+ - / * %</code></td><td align="left">Binary infix numeric operations</td></tr><tr><td align="left"><code class="code">-</code></td><td align="left">Unary negation</td></tr><tr><td align="left"><code class="code">++ --</code></td><td align="left">Post-increment, pre-increment, post-decrement, pre-decrement</td></tr><tr><td align="left"><code class="code">+= -= *= /= %=</code></td><td align="left">Shorthands for variable updating</td></tr></tbody></table></div><p class="title"><b>Table 2. Numeric operators and assignment</b></p></div><br class="table-break"></div><div class="section" title="Bitwise operators"><div class="titlepage"><div><div><h5 class="title"><a name="id2748308"></a>Bitwise operators</h5></div></div></div><p>In order to understand the next set of operators you need to understand how integer numbers are stored in memory as binary numbers. If you have not seen binary numbers before, this section might take you some time to work through; paying careful attention to binary numbers now will pay dividends later.</p><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>We have provided some programs to help visualise the conversion
between binary and decimal numbers.  These can be downloaded from the
course webpage.</p></div><div class="section" title="Counting with decimal, binary and hexadecimal"><div class="titlepage"><div><div><h6 class="title"><a name="id2755103"></a>Counting with decimal, binary and hexadecimal</h6></div></div></div><p>Binary numbers can be explained by analogy to "normal" numbers. The number system used on a daily basis today is called the decimal number system, sometimes called <em class="firstterm">base 10 arithmetic</em>. The decimal system requires 10 unique digits (0, 1, 2, 3, 4, 5, 6, 7, 8 and 9) to write down a number. For example, the number 6409 has 6 thousands (10<sup>3</sup>), 4 hundreds (10<sup>2</sup>), no tens (10<sup>1</sup>) and 9 ones (10<sup>0</sup>); hence 6409 can be written as 6 × 10 <sup>3</sup> + 4 × 10<sup>2</sup> + 0 × 10<sup>1</sup> + 9 × 10<sup>0</sup>.</p><p>Binary numbers use base 2 arithmetic and consequently, there are only two digits in binary (0 and 1). Binary arithmetic is often used in computers because it simplifies the hardware design. The binary number 1011 has one eight (2<sup>3</sup>), no fours (2<sup>2</sup>), one two (2<sup>1</sup>) and one one (2<sup>0</sup>); hence the number 1011 can be written as 1 × 2<sup>3</sup> + 0 × 2<sup>2</sup> + 1×2<sup>1</sup> + 1×2<sup>0</sup>, or 11 in decimal. In the preceding example, the binary number was written so that the leftmost position represented the binary value with the highest power of two and the rightmost position represented the least. This is identical to our "normal" decimal number system. For binary numbers we refer to the leftmost position as the <em class="firstterm">most significant bit</em> and the rightmost position as the <em class="firstterm">least significant bit</em>.</p><p>A binary number can be converted into its decimal equivalent by adding up all the powers of 2 where there is a corresponding 1 in the binary representation. In other words, if there is a 1 at position i in the number then you include 2<sup>i</sup> in the summation used to calculate the equivalent decimal number. By convention, the least significant bit is found at position 0. Therefore the most significant bit position in an n-bit binary number is n-1.</p><p>Hexadecimal notation is used to represent counting in base 16. In	this notation we have 16 different digits (0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E and F). In Java, a literal value is written in hexadecimal by prefixing the number with the characters <code class="code">0x</code> (a zero and lowercase x) in order to avoid confusion with decimal numbers. For example, the hexadecimal number <code class="code">0x1FAD</code> has a single four thousand and ninety six (4096 = 16<sup>3</sup>), fifteen (written as <code class="code">F</code>) two hundred and fifty sixes (256 = 16<sup>2</sup>), ten (written as <code class="code">A</code>) sixteens (16<sup>1</sup>) and thirteen (written as <code class="code">D</code>) ones (16<sup>0</sup>). In other words, <code class="code">0x1FAD</code> can be written as 1 × 16<sup>3</sup> + 15 × 16<sup>2</sup> + 10 × 16<sup>1</sup> + 13 × 16<sup>0</sup>.</p><p>Hexadecimal numbers are popular with programmers because and they are easily converted to binary numbers with simple mental arithmetic and offer a more compact representation than writing a binary number directly. They also allow us to write numbers which spell out (rude) words. Java also supports octal numbers (base 8) and a literal value can be written in octal by prefixing the number with a leading zero. For example, the octal number <code class="code">077</code> has the value 63 in decimal.</p></div><div class="section" title="The bitwise logical operators"><div class="titlepage"><div><div><h6 class="title"><a name="id2726826"></a>The bitwise logical operators</h6></div></div></div><div class="important" title="Important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>We have provided some programs to help visualise the operation
of the bitwise operators.  These can be downloaded from the course
webpage.</p></div><p>The bitwise logical operators perform logical operations on the binary representation of integers. For each of the n bits in the number, the bit at position i in the left-hand operand is combined with the bit in position i in the right-hand operand; these two bits are used to produce the bit at position i in the result. The operators are as follows:
</p><div class="variablelist"><dl><dt><span class="term"><code class="code">&amp;</code> (bitwise AND)</span></dt><dd><p>The output bit is set only if the corresponding bits in the right-hand operand <span class="emphasis"><em>and</em></span> in the left-hand operand are set;</p></dd><dt><span class="term"><code class="code">|</code> (bitwise OR)</span></dt><dd><p>The output bit is set if the corresponding bits in left-hand operand <span class="emphasis"><em>or</em></span> in the right-hand operand are set;</p></dd><dt><span class="term"><code class="code">^</code> (bitwise XOR)</span></dt><dd><p>The output bit is set if the corresponding bit in the left-hand operand is <span class="emphasis"><em>different</em></span> to the bit in right-hand operand.</p></dd></dl></div><p>For example, <code class="code">23 &amp; 24</code> gives the result <code class="code">16</code>, or in binary, 10111 <span class="emphasis"><em>AND</em></span> 11000 equals 10000.</p></div><div class="section" title="The shift operators"><div class="titlepage"><div><div><h6 class="title"><a name="id2726936"></a>The shift operators</h6></div></div></div><p>The shift operators are used to move the bits in a number left (towards the most significant bit) or right (towards the least significant bit). They are written as <code class="code">&lt;&lt;</code> and <code class="code">&gt;&gt;</code> for left and right shift respectively. For example, the expression <code class="code">45&gt;&gt;3</code> shifts the bits representing the value <code class="code">45</code> (written in binary as 101101) right three places, resulting in the value <code class="code">5</code> (written in binary as 101).</p><div class="sidebar" title="Right and left shift"><p class="title"><b>Right and left shift</b></p><p>Modify your implementation of <code class="code">PrimitiveInt</code> to test your answers to the following questions.</p><div class="orderedlist"><ol class="orderedlist" start="4" type="1"><li class="listitem"><p> Find the value of <code class="code">x</code> and <code class="code">y</code> such that</p><p>i. <code class="code">0x55&gt;&gt;x</code> equals 5,</p><p>ii. <code class="code">0x55&lt;&lt;y</code> equals 10880.</p></li><li class="listitem"><p> Explain why <code class="code">1&lt;&lt;n</code> gives the value 2<sup>n</sup>.
 </p></li><li class="listitem"><p> Combine the right shift and bitwise-and operators to give an expression which evaluates to <code class="code">1</code> if a variable <code class="code">x</code> has its fifth bit set, and <code class="code">0</code> otherwise.
 </p></li></ol></div></div></div><div class="section" title="Negative numbers"><div class="titlepage"><div><div><h6 class="title"><a name="id2727057"></a>Negative numbers</h6></div></div></div><p>The binary number system described so far cannot represent negative numbers. Most modern computers use a method called <em class="firstterm">2's complement</em> which is able to represent both positive and negative numbers. In this scheme the most significant bit in an n-bit binary number represents -2<sup>(n-1)</sup> whilst the remaining bits at position i (where 0 <span class="symbol">≤</span> i &lt; n-1) represent the positive values 2<sup>i</sup> as in earlier sections. For example, the 8-bit binary number 10001100 is decoded as minus one hundred and twenty eight (-128 = -2<sup>7</sup>) plus eight (8 = 2<sup>3</sup>), plus four (4 = 2<sup>2</sup>); in other words -2<sup>7</sup> + 2<sup>3</sup> + 2<sup>2</sup> = -116. This representation might seem a little odd, but it is appealing from the hardware design point of view (understanding why this is the case is beyond the scope of this course).</p><p>The right-shift operator <code class="code">&gt;&gt;</code>  performs <em class="firstterm">sign extension</em>, which means that the value of the most siginificant bits added during the right-shift operation are filled with the value of the most significant bit rather then with zeros. The alternative right-shift operator <code class="code">&gt;&gt;&gt;</code> performs a right-shift <span class="emphasis"><em>without</em></span> sign extension, and therefore the top bits are always filled with zeros.</p><p>There is only one unary bitwise operator in Java, tilde (<code class="code">~</code>), which negates every bit found in its argument; in other words it, swaps 1 for 0 and 0 for 1. A table summarising the bitwise operators is shown in <a class="xref" href="#tab:bitwise" title="Table 3. Numeric operators and assignment">Table 3, “Numeric operators and assignment”</a></p><div class="table"><a name="tab:bitwise"></a><div class="table-contents"><table summary="Numeric operators and assignment" border="1"><colgroup><col align="left"><col align="left"></colgroup><tbody><tr><td align="left"><code class="code">&amp; | ^</code></td><td align="left">Bitwise binary infix operators and, or and xor</td></tr><tr><td align="left"><code class="code">~</code></td><td align="left">Bitwise unary negation</td></tr><tr><td align="left"><code class="code">&lt;&lt; &gt;&gt; &gt;&gt;&gt;</code></td><td align="left">Bitwise left and right shift with and without sign-extension</td></tr><tr><td align="left"><code class="code">&amp;= |= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=</code></td><td align="left">Shorthand notation for updating the value held in a variable</td></tr></tbody></table></div><p class="title"><b>Table 3. Numeric operators and assignment</b></p></div><br class="table-break"></div></div></div><div class="section" title="Literal values"><div class="titlepage"><div><div><h4 class="title"><a name="literal%20values"></a>Literal values</h4></div></div></div><p>As you have seen earlier in the workbook, literal values for <code class="code">int</code> can be written in one of three ways:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>in decimal as you might expect (e.g. <code class="code">52</code>),</p></li><li class="listitem"><p>in octal by prefixing the literal with <code class="code">0</code> (e.g. <code class="code">064</code>), or</p></li><li class="listitem"><p>in hexadecial by prefixing the literal with <code class="code">0x</code> (e.g. <code class="code">0x34</code>).</p></li></ul></div><p>

You can write literal values for <code class="code">long</code> similarly, except that you must postfix the literal with an <code class="code">L</code> (i.e. <code class="code">52L</code>, <code class="code">064L</code> and <code class="code">0x34L</code>). It's not possible to write a literal value of type <code class="code">byte</code> or <code class="code">short</code>. If you want to store a literal into a variable of type <code class="code">short</code> or <code class="code">byte</code> you can do so by assigning an <code class="code">int</code> literal which will be converted to a value of the correct type automatically. For example,

</p><pre class="programlisting">short myShort = 12;
</pre><p>
</p><p>The <code class="code">char</code> type is 16-bits wide and is normally used to store values representing characters, but can also be used to store and retrieve integral values. Java supports unicode,<sup>[<a name="id2767794" href="#ftn.id2767794" class="footnote">4</a>]</sup> making programs which support non-latin character sets easy to write. You can embed unicode characters in literal text strings inside Java source code, and even use unicode characters for variable, field, method or class names. You can specify literal values for <code class="code">char</code> variables by:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p>placing the character that you want inside single quotes (e.g. <code class="code">'A'</code>),</p></li><li class="listitem"><p>providing a unicode value inside single quotes (e.g. <code class="code">'\u0065'</code>), or</p></li><li class="listitem"><p>providing an integer value (e.g. <code class="code">65</code>).</p></li></ul></div><p>
</p></div></div><div class="section" title="Floating-point types"><div class="titlepage"><div><div><h3 class="title"><a name="float-types"></a>Floating-point types</h3></div></div></div><p>The storage of floating point values in <code class="code">float</code> and <code class="code">double</code> types is based on the IEEE 754 standard. Internally, floating point values are represented by a sign bit, a mantissa and an exponent, which means these types can store a much larger range of values at the expense of reduced precision. Therefore it is natural to express values in scientific notation such as 1.23 × 10 <sup>-42</sup>, which can be written in Java as <code class="code">1.23e-42</code>. In Java all literal floating point values are of type <code class="code">double</code> unless explicitly postfixed with <code class="code">F</code> in which case they are of type <code class="code">float</code>. Because the precision of values stored in variables of type <code class="code">float</code> is poor, you should always use a <code class="code">double</code> type unless you have undertaken a careful analysis to assertain that a <code class="code">float</code> will provide sufficient accuracy. Such floating point issues are beyond the scope of this course and will be covered in more detail in the Floating Point Computation course.</p></div><div class="section" title="The boolean type and operators"><div class="titlepage"><div><div><h3 class="title"><a name="boolean-type"></a>The boolean type and operators</h3></div></div></div><p>The <code class="code">boolean</code> type does not have any explicit storage size assigned to it: it can only store one of two literal values, <code class="code">true</code> or <code class="code">false</code>. There are six binary comparison operators in Java which take two primitive types <code class="code">a</code> and <code class="code">b</code> and produce a value with a <code class="code">boolean</code> type as a result. The value (<code class="code">false</code> or <code class="code">true</code>) depends on the values of <code class="code">a</code> or <code class="code">b</code> and the choice of operator:

</p><div class="itemizedlist"><ul class="itemizedlist" type="disc" compact><li class="listitem"><p><code class="code">a</code> equals <code class="code">b</code> (written <code class="code">a==b</code>),</p></li><li class="listitem"><p><code class="code">a</code> does not equal <code class="code">b</code> (<code class="code">a!=b</code>),</p></li><li class="listitem"><p><code class="code">a</code> is less than <code class="code">b</code> (<code class="code">a&lt;b</code>)</p></li><li class="listitem"><p><code class="code">a</code> is less than or equal to <code class="code">b</code> (<code class="code">a&lt;=b</code>)</p></li><li class="listitem"><p><code class="code">a</code> is greater than <code class="code">b</code> (<code class="code">a&gt;b</code>)</p></li><li class="listitem"><p><code class="code">a</code> is greater than or equal to <code class="code">b</code> (<code class="code">a&gt;=b</code>)</p></li></ul></div><p>

Expressions or values of type <code class="code">boolean</code> can be combined together using the binary logical operators for <span class="emphasis"><em>or</em></span> (<code class="code">|</code>) and <span class="emphasis"><em>and</em></span> (<code class="code">&amp;</code>) as well as the unary operator for <span class="emphasis"><em>not</em></span> (<code class="code">!</code>). Remember that whilst the operators <code class="code">&amp;</code> and <code class="code">|</code> <span class="emphasis"><em>look</em></span> identical to the bitwise operators for AND and OR, they take values of a different type, and perform completely different actions!
</p><p>Here are some examples of expressions using a variety of operators mentioned so far:

</p><pre class="programlisting">int a = (1+2)*3;                    //9
int b = 1+2*3;                      //7
boolean t1 = a == b;                //false
boolean t2 = a &gt;= b+2;              //true
boolean t3 = a != b &amp; !(a % 4 &gt; 1); //true
boolean t4 = t1 | t2 &amp; t3;          //false
</pre><p>
</p><p>Java also has two short-circuit boolean operators written as <code class="code">&amp;&amp;</code> and <code class="code">||</code> which behave identically to <code class="code">&amp;</code> and <code class="code">|</code> respectively except as outlined in the following text. If the left operand of <code class="code">&amp;&amp;</code> evaluates to <code class="code">false</code> then the right operand is <span class="emphasis"><em>not evaluated</em></span>; similarly if the left operand of <code class="code">||</code> evaluates to <code class="code">true</code> then the right operand is <span class="emphasis"><em>not evaluated</em></span>. This is generally sensible, since it does not affect the result of the expression and saves the computer from evaluating the contents of the right operand. The only exception to this is if the right operand has a <span class="emphasis"><em>side-effect</em></span> such as updating the contents of a variable, in which case you should use the normal boolean operator not the short-circuit one.</p></div></div><div class="section" title="Comments"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="sec:comments"></a>Comments</h2></div></div></div><p>You will often want to provide comments in your code to document how a particular piece of code works, or provide extra information to other programmers who might read or modify your code. You can write comments in Java in one of two ways:

</p><pre class="programlisting">/* A comment which can span
   multiple lines */

//A comment which contines until the end of the line
</pre><p>
A multi-line comment starts with <code class="code">/*</code> and finishes with <code class="code">*/</code>; multi-line comments cannot be nested (in other words, a comment cannot contain the characters <code class="code">/*</code> or <code class="code">*/</code> within it. A single line comment starts with <code class="code">//</code> and continues until the end of the line.
</p><p>
If you are writing a large application or library, you will probably want to write more extensive documentation to help other software developers use the library or maintain your software. Java supports <em class="firstterm">javadoc</em> to do this. Javadoc is a command line tool which examines your source code, looking for multi-line comments which start with <code class="code">/**</code> and uses the information held within the comment as well as its location in the source file to generate HTML documentation for the software project. Javadoc is beyond the scope of this course, although the interested reader who wants to know more may like to take a look at Sun's documentation.<sup>[<a name="id2768219" href="#ftn.id2768219" class="footnote">5</a>]</sup>
</p></div><div class="section" title="Java Tick 1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2768231"></a>Java Tick 1</h2></div></div></div><p>A Java <code class="code">long</code> is an integer with 64 bits. Your task is to write a class called <code class="code">PackedLong</code> which uses the 64 bits inside the java <code class="code">long</code> integer to store 64 boolean values. We will make use of the PackedLong class next week as the basis for our Game of Life implementation. You should create a source file called <code class="filename">PackedLong.java</code> inside the directory structure <code class="filename">uk/ac/cam/your-crsid/tick1/</code> where <code class="code">your-crsid</code> is your username. Place the following code inside <code class="filename">PackedLong.java</code>:

</p><pre class="programlisting">package uk.ac.cam.your-crsid.tick1; //TODO: replace your-crsid
		
public class PackedLong {
			
 /*
  * Unpack and return the nth bit from the packed number at index position;
  * position counts from zero (representing the least significant bit)
  * up to 63 (representing the most significant bit).
  */
 public static boolean get(long packed, int position) {
  // set "check" to equal 1 if the "position" bit in "packed" is set to 1
  long check = //TODO: complete this statement
  
  return (check == 1);
 }

 /*
  * Set the nth bit in the packed number to the value given
  * and return the new packed number
  */
 public static long set(long packed, int position, boolean value) {
  if (value) {
   // TODO: complete this
   // update the value "packed" with the bit at "position" set to 1
  }
  else {
   // TODO: complete this
   // update the value "packed" with the bit a "position" set to 0 
  }
  return packed;
 }
}
</pre><p>
</p><p>The <code class="code">PackedLong</code> class does not contain a special "main" method. Consequently this means that it cannot be executed directly using the <code class="code">java</code> command line program. Do not add a main method to this class; instead create two extra Java source files inside the same directory structure. Save the following program into <code class="code">uk/ac/cam/your-crsid/tick1/TestBit.java</code>:
	
</p><pre class="programlisting">package uk.ac.cam.your-crsid.tick1; //TODO: replace your-crsid
		
public class TestBit {
 public static void main(String[] args) throws Exception {
  long currentValue = Long.decode(args[0]);
  int position = Integer.parseInt(args[1]);
  boolean value = PackedLong.get(currentValue, position);
  System.out.println(value);
 }
}
</pre><p>
	
</p><p>Save the following program into <code class="code">uk/ac/cam/your-crsid/tick1/SetBit.java</code>:

</p><pre class="programlisting">package uk.ac.cam.your-crsid.tick1; //TODO: replace your-crsid

public class SetBit {
 public static void main(String [] args) throws Exception {
  long currentValue = Long.decode(args[0]);
  int position = Integer.parseInt(args[1]);
  boolean value = Boolean.parseBoolean(args[2]);
  currentValue = PackedLong.set(currentValue,position,value);       
  System.out.println(currentValue);
 }
}
</pre><p>		
</p><p>Once you have written your <code class="code">PackedLong</code> implementation, you should be able to test your code using the two supplied programs.</p><p>The <code class="code">TestBit</code> program accepts two arguments on the command line. The first argument is a <code class="code">long</code> value which represents the 64 boolean bits, and the second argument tells the <code class="code">TestBit</code> program which boolean value to print out. For example, executing

</p><pre class="programlisting">java uk.ac.cam.your-crsid.tick1.TestBit 85 4</pre><p>

should produce the answer "<code class="code">true</code>". If it does not, your implementation of <code class="code">PackedLong</code> is incorrect. The <code class="code">SetBit</code> program accepts three arguments on the command line. The first is the <code class="code">long</code> value which represents the 64 boolean bits, the second argument tells <code class="code">SetBit</code> which bit to set, and the third argument tells <code class="code">SetBit</code> whether the chosen bit in the new value should be set to 1 (to represent <code class="code">true</code>) or 0 (to represent <code class="code">false</code>). For example, executing 

</p><pre class="programlisting">java uk.ac.cam.your-crsid.tick1.SetBit 85 2 false</pre><p> 

should produce the answer "<code class="code">81</code>". If it does not, then your implementation of <code class="code">PackedLong</code> is incorrect.</p><p>Testing your implementation with the two examples above will probably not be sufficient to locate all the errors in your implementation of <code class="code">PackedLong</code>. Therefore you should produce a more complete list of test cases, paying particular attention to sign extension. Once you are happy with your program you should submit a jar file named <code class="code">crsid-tick1.jar</code> to <code class="code">ticks1a-java@cl.cam.ac.uk</code> for testing, remembering to replace <code class="code">crsid</code> with your username. Your jar file should contain the following files:

</p><pre class="programlisting">META-INF/
META-INF/MANIFEST.MF
uk/ac/cam/your-crsid/tick1/SetBit.class
uk/ac/cam/your-crsid/tick1/SetBit.java
uk/ac/cam/your-crsid/tick1/TestBit.class
uk/ac/cam/your-crsid/tick1/TestBit.java
uk/ac/cam/your-crsid/tick1/PackedLong.class
uk/ac/cam/your-crsid/tick1/PackedLong.java
answers.txt
</pre><p>
</p><p> Note: you know how to build a jar file with a specified entry point in order to tell the Java runtime program how to execute the program within the jar file. There are two candidates for the entry point in this tick: <code class="code">TestBit</code> and <code class="code">SetBit</code>. Please make <code class="code">TestBit</code> the entry point for your jar file.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2722753" href="#id2722753" class="para">1</a>] </sup><a class="ulink" href="http://en.wikipedia.org/wiki/Conway's_Game_of_Life" target="_top">http://en.wikipedia.org/wiki/Conway's_Game_of_Life</a></p></div><div class="footnote"><p><sup>[<a name="ftn.id2723582" href="#id2723582" class="para">2</a>] </sup><a class="ulink" href="http://www.gnu.org/software/bash/manual/bashref.html" target="_top">http://www.gnu.org/software/bash/manual/bashref.html</a></p></div><div class="footnote"><p><sup>[<a name="ftn.id2751667" href="#id2751667" class="para">3</a>] </sup><a class="ulink" href="http://www.cl.cam.ac.uk/~mgk25/iso-time.html" target="_top">http://www.cl.cam.ac.uk/~mgk25/iso-time.html</a></p></div><div class="footnote"><p><sup>[<a name="ftn.id2767794" href="#id2767794" class="para">4</a>] </sup><a class="ulink" href="http://en.wikipedia.org/wiki/Unicode" target="_top">http://en.wikipedia.org/wiki/Unicode</a></p></div><div class="footnote"><p><sup>[<a name="ftn.id2768219" href="#id2768219" class="para">5</a>] </sup><a class="ulink" href="http://java.sun.com/j2se/javadoc/writingdoccomments/" target="_top">http://java.sun.com/j2se/javadoc/writingdoccomments/</a></p></div></div></div><p class="docfooter">Copyright 2008-2012 Alastair R. Beresford and Andrew C. Rice</p></body></html>
